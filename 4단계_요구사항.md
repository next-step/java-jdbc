# 🚀 4단계 - 트랜잭션 동기화 구현하기

# **미션 설명**

UserService에서 changePassword() 메서드를 하나의 트랜잭션으로 처리하려면 Connection 객체가 비즈니스 로직과 섞이게 된다.

이 문제를 해결하기 위해 **트랜잭션 동기화(Transaction synchronization)** 방식을 사용해보자.

트랜잭션 동기화란 트랜잭션을 시작하기 위한 Connection 객체를 따로 보관해두고, DAO에서 호출할 때 저장된 Connection을 가져다 사용하는 방식이다.

**`DataSourceUtils`**와 **`TransactionSynchronizationManager`**를 활용하여 DAO가 Connection 객체를 파라미터로 전달받아 사용하지 않도록 만들어보자.

# **기능 요구 사항**

## **1. Transaction synchronization 적용하기**

서비스와 DAO에서 Connection 객체를 가져오는 부분은 **`DataSourceUtils`**를 사용하도록 수정하자.

그리고 **`TransactionSynchronizationManager`** 클래스가 올바르게 작동하도록 구현해보자.

```java
public void changePassword(final long id, final String newPassword, final String createdBy) {
    Connection connection = DataSourceUtils.getConnection(dataSource);
    connection.setAutoCommit(false);

    try {
        // todo
        connection.commit();
    } catch (...) {
        connection.rollback();
        ...
    } finally {
        DataSourceUtils.releaseConnection(connection, dataSource);
        TransactionSynchronizationManager.unbindResource(dataSource);
    }
}

```

## **생각해보기 🤔**

JDBC가 아닌 JPA, JMS 같이 다른 커넥션을 사용하거나 2개 이상의 데이터소스를 하나의 트랜잭션처럼 관리하려면 어떻게 해야 할까?

스프링에서는 이 문제를 PlatformTransactionManager를 사용하여 해결한다.

PlatformTransactionManager가 어떻게 추상화되어 있는지는 스프링 문서를 참고하자.

추가로 로컬 트랜잭션, 글로벌 트랜잭션, JTA 라는 세 가지 키워드도 같이 학습하자.

# 

## **2. 트랜잭션 서비스 추상화하기**

트랜잭션 동기화를 적용하여 DAO에게 Connection 객체를 전달하는 코드를 개선할 수 있었다.

하지만 여전히 UserService에 데이터 액세스와 관련된 로직이 남아있다.

인터페이스를 활용하여 트랜잭션 서비스를 추상화하여 비즈니스 로직과 데이터 액세스 로직을 분리해보자.

먼저 아래와 같은 인터페이스를 추가한다.

```java
public interface UserService {

    User findById(final long id);
    void save(final User user);
    void changePassword(final long id, final String newPassword, final String createdBy);
}

```

그리고 UserService 인터페이스를 구현한 클래스 2개를 만든다.

```java
public class AppUserService implements UserService {
    // todo
}

```

```java
...
public class TxUserService implements UserService {

    private final UserService userService;

    // override 대상인 메서드는 userService의 메서드를 그대로 위임(delegate)한다.
    @Override
    public void changePassword(final long id, final String newPassword, final String createdBy) {
        // 트랜잭션 처리 영역

        userService.changePassword(id, newPassword, createdBy);

        // 트랜잭션 처리 영역
    }
}

```

UserServiceTest 클래스의 testTransactionRollback() 테스트 메서드를 아래와 같이 바꿔보자.

그리고 테스트가 통과하도록 만들자.

테스트 코드를 통과시키고 미션을 마무리한다.@Transactional 미션에서 이번에 작성한 코드를 프로덕션 코드으로 적용한다.

@Test
void testTransactionRollback() {
// 트랜잭션 롤백 테스트를 위해 mock으로 교체
final var userHistoryDao = new MockUserHistoryDao(jdbcTemplate);
// 애플리케이션 서비스
final var appUserService = new AppUserService(userDao, userHistoryDao);
// 트랜잭션 서비스 추상화
final var userService = new TxUserService(appUserService);

    final var newPassword = "newPassword";
    final var createdBy = "gugu";
    // 트랜잭션이 정상 동작하는지 확인하기 위해 의도적으로 MockUserHistoryDao에서 예외를 발생시킨다.
    assertThrows(DataAccessException.class,
            () -> userService.changePassword(1L, newPassword, createdBy));

    final var actual = userService.findById(1L);

    assertThat(actual.getPassword()).isNotEqualTo(newPassword);
}

---
## 요구사항 정리
[ ] 1. Transaction synchronization 적용하기
[ ] 2. 트랜잭션 서비스 추상화하기
    - [ ] UserService 인터페이스를 추가하여 비즈니스 로직과 데이터 접근 로직ㅡㄹ 분리한다

## 1. 로컬트랜잭션
로컬 트랜잭션(Local Transaction)은 하나의 데이터소스나 리소스에 대해서만 트랜잭션을 관리하는 단일 리소스 트랜잭션입니다. 로컬 트랜잭션은 특정 데이터베이스 연결 또는 특정 리소스에 종속되며, 이 트랜잭션은 주로 데이터베이스 수준에서 관리됩니다.
### 특징
1. 단일리소스: 하나의 데이터소스나 리소스에서 발생하는 작업만을 대상으로한다. 예를 들어, 하나의 데이터베이스 연결에서 발생하는 여러 SQL 쿼리를 하나의 트랜잭션으로 묶는것
2. 트랜잭션관리: 일반적으로 데이터베이스 관리 시스템 (DBMS) 에서 직접 관리된다. JPA 와같은 API 를 사용하여 트랜잭션을 관리하고 `commit()`, `rollback()` 메서드를 통해 트랜잭션을 종료할 수 있음
3. 간단한 설정: 설정과 관리가 간단하며, 하나의 데이터소스만을 다루기 때문에 분산트랜잭션보다 성능적으로 유리
4. 제한된 범위: 로컬 트랜잭션은 하나의 데이터소스에만 적용되기 때문에 여러 데이터소스나 리소스를 사용하는 경우에는 트랜잭션을 일관되게 관리할 수 없음. 이 경우 분산 트랜잭션을 사용해야 함

## 2. 글로벌트랜잭션
**글로벌 트랜잭션(Global Transaction)**은 여러 분산된 리소스(예: 여러 데이터베이스, 메시지 큐, 파일 시스템 등)에 걸쳐 수행되는 작업을 하나의 트랜잭션으로 묶어 관리하는 트랜잭션입니다. 글로벌 트랜잭션은 분산 트랜잭션(Distributed Transaction)이라고도 하며, 이를 관리하기 위해 **JTA(Java Transaction API)**와 같은 트랜잭션 관리자를 사용합니다.
### 특징
1. 분산 리소스 관리: 여러 분산된 시스템 리소스 간의 일관성 보장
2. ACID 속성 보장: 모든 리소스에 대한 작업이 성공하면 트랜잭션이 커밋되고, 하나라도 실패하면 트랜잭션이 롤백됨
3. JTA: (밑에서 따로 정리)
4. 2단계 커밋 프로토콜: 2단계 커밋 프로토콜 (Two-Phase Commit, 2PC) 사용

## 3. JTA
**JTA(Java Transaction API)**는 Java 플랫폼에서 트랜잭션을 관리하기 위한 표준 API입니다. 주로 분산 트랜잭션 관리에 사용되며, 여러 리소스(예: 데이터베이스, 메시지 큐 등)에 걸쳐 트랜잭션을 일관되게 처리할 수 있도록 도와줍니다. JTA는 Java EE(Enterprise Edition) 환경에서 자주 사용되지만, Spring 같은 프레임워크에서도 사용할 수 있습니다.
### 주요기능
1. 글로벌 트랜잭션 관리: JTA는 여러 리소스에 걸쳐 발생하는 트랜잭션을 하나의 트랜잭션으로 묶어 관리할 수 있습니다. 이는 여러 데이터베이스와 메시지 큐를 동시에 다루는 분산 시스템에서 매우 유용합니다.
2. 트랜잭션 전파: 트랜잭션 전파를 통해, 현재 트랜잭션 컨텍스트를 유지하면서 메서드 호출 간에 트랜잭션을 전달할 수 있습니다. 이는 트랜잭션 전파 정책(propagation policy)을 통해 제어됩니다.
3. 컨테이너 관리 트랜잭션: Java EE 컨테이너는 JTA를 사용하여 트랜잭션을 자동으로 관리할 수 있습니다. 이 방식에서는 개발자가 트랜잭션을 직접 제어할 필요 없이, 컨테이너가 트랜잭션 경계를 처리합니다.
4. 표준화된 트랜잭션 관리: JTA는 Java EE에서 트랜잭션 관리의 표준을 제공하며, 이를 통해 애플리케이션 코드를 리소스나 환경에 독립적으로 유지가능
